# MCP Server Configuration Management

This document outlines the hybrid approach for managing Multi-Client-Provider (MCP) server configurations within this NixOS setup. The goal is to maintain a reproducible, modular, and adaptable system for handling API keys and server settings for applications like Gemini, Opencode, etc.

- **Global Configuration**: Managed declaratively via Nix and Home Manager. This is the primary, automated method.
- **Project-Specific Configuration**: A manual, on-demand process to generate configuration files within specific project directories.

---

## How It Works: The Nix-Python Bridge

A core challenge is providing a non-Nix Python script (`generate_configs.py`) with access to secrets that are managed by `sops-nix` and whose paths are only determined at build time.

We solve this with a "bridge" mechanism:

1.  **SOPS Secrets**: API keys are stored in `secrets/secrets.yaml` and exposed to the Nix configuration via `sops-nix`.
2.  **Nix Wrappers**: For each secret, a small Nix module in `modules/home/mcp/wrappers/` creates a file. The content of this file is the *path* to the actual, decrypted secret managed by `sops-nix`. This is a level of indirection.
3.  **Template Substitution**: The `master-servers.json` file acts as a template, with placeholders like `@placeholder_path@`.
4.  **Activation Script**: During a `home-manager switch`, an activation script uses `pkgs.substituteAll` to replace the placeholders in the template with the real paths generated by the Nix wrappers. This creates a temporary, complete `servers.json` file.
5.  **Python Script**: The activation script then runs `generate_configs.py`, pointing it to the temporary `servers.json`. The Python script reads this file, follows the paths to get the actual secrets, and generates the final client JSON configuration files (e.g., `~/.config/gemini/settings.json`).

---

## File Structure

-   `master-servers.json`: A template file listing all server definitions with placeholders for secret paths.
-   `master-clients.json`: Defines the client applications and where their global configuration files should be stored.
-   `generate_configs.py`: The Python script that reads the completed server template and generates the final JSON configs for each client.
-   `wrappers/`: A directory of Nix modules that act as the bridge between `sops-nix` and the generation script.
    -   `default.nix`: The main entrypoint that imports all other wrappers and orchestrates the substitution and script execution.
    -   `*-wrapper.nix`: Individual wrappers for each server secret.
-   `README.md`: This file.
-   `TODO.md`: A list of tasks for future enhancements.

---

## Workflow: Adding a New MCP Server

Follow these steps to add a new server and its secret to the global configuration.

### Step 1: Add the Secret to SOPS

1.  Encrypt your new API key or secret and add it to `secrets/secrets.yaml`. Use a descriptive key, for example:
    ```yaml
    mcp/new-server-name: "ENC[...]"
    ```
2.  Expose this secret to the configuration by adding it to `modules/home/sops.nix` under `sops.secrets`.

### Step 2: Create a Nix Wrapper

1.  Create a new file in `modules/home/mcp/wrappers/` named `new-server-name-wrapper.nix`.
2.  Add the following content, replacing `new-server-name` with the actual name of your server/secret key.

    ```nix
    # modules/home/mcp/wrappers/new-server-name-wrapper.nix
    { config, pkgs, lib, ... }:

    let
      # This creates a file in the Nix store.
      # The *content* of the file is the path to the decrypted SOPS secret.
      secretPathFile = pkgs.writeTextFile {
        name = "new-server-name-secret-path";
        text = config.sops.secrets."mcp/new-server-name".path;
      };
    in
    {
      # Define a new Nix option to hold the path to our generated file.
      options.custom.mcp.secrets.new-server-name-path = lib.mkOption {
        type = lib.types.path;
        internal = true;
        description = "Path to the file that contains the path to the 'new-server-name' secret.";
      };

      # Assign the path of our generated file to the new option.
      config.custom.mcp.secrets.new-server-name-path = secretPathFile;
    }
    ```

### Step 3: Auto-Import Verification

The `modules/home/mcp/wrappers/default.nix` automatically imports all `*.nix` files in its directory. You don't need to manually add importsâ€”just ensure your new file ends with `-wrapper.nix` and is in the `wrappers/` directory.

**Important:** After creating your wrapper file, run `git add modules/home/mcp/wrappers/your-wrapper.nix` to ensure Nix flakes can see it.

### Step 4: Update the `master-servers.json` Template

Add a new server object to the `servers` list in `modules/home/mcp/master-servers.json`. Use a unique placeholder for the `api_key_path_file`.

```json
{
  "servers": [
    ...
    {
      "name": "new-server-name",
      "model": "some-model-id",
      "api_key_path_file": "@new_server_name_secret_path@",
      "base_url": "https://api.example.com/v1"
    }
  ]
}
```

### Step 5: Update the Substitution Map

In `modules/home/mcp/wrappers/default.nix`, add your new placeholder and the Nix option you created to the `substituteAll` call.

```nix
# modules/home/mcp/wrappers/default.nix
...
let
  serversConfig = pkgs.substituteAll {
    src = ../master-servers.json;
    # Add this line
    new_server_name_secret_path = config.custom.mcp.secrets.new-server-name-path;
    ...
  };
in
...
```

### Step 6: Rebuild Your Configuration

Run `hs` (or `home-manager switch`). The activation script will now automatically generate the configuration for your new server.

### Step 7: Verify Installation

After the rebuild completes, verify your wrapper is available:

```bash
# Check the wrapper is in PATH
which your-server-wrapper

# Test it runs (expect it to wait for stdio input or show usage)
your-server-wrapper
```

If `which` returns nothing, see the Troubleshooting section below.

---

## Troubleshooting & Lessons Learned

Adding a new MCP server can sometimes be complex. The process of adding the `anki-mcp-server` revealed several key lessons that can make future integrations smoother.

### 1. Flakes and Git: Track Your Files!

The single most important lesson is that **Nix flakes ignore untracked files by default**. If you create a new file (like a new `*-wrapper.nix`), the flake-based build (`hs`, `ns`, `nix build`) will not see it, and your changes will be silently ignored, leading to confusing behavior.

**Workflow:**
1.  After creating or modifying files, **always run `git status`** to see what has changed.
2.  Use **`git add <your-new-file.nix>`** to stage new and modified files *before* attempting to build.

### 2. Identify the Project Type Correctly

Before attempting to package a server, correctly identify its language and ecosystem.
- Is there a `package.json`? It's a **Node.js** project.
- Is there a `Cargo.toml`? It's a **Rust** project.
- Is there a `pyproject.toml` or `requirements.txt`? It's a **Python** project.

This was a major stumbling block during the `anki-mcp-server` integration, which was mistaken for a Rust project when it was actually a Node.js project.

### 3. Packaging Patterns for New Servers

There isn't a single way to package a new server. Based on this configuration, here are the patterns in order of preference:

#### Pattern A: Pre-built Package (e.g., from npm)
This is the `context7` pattern. If a server is available on a public registry like npm, this is the easiest method. The wrapper script uses `npx` to run it.

```nix
# In your-wrapper.nix
# ...
exec ${pkgs.nodejs}/bin/npx -y @some-scope/some-package@latest "$@"
# ...
```

#### Pattern B: Local Repository (The `anki-mcp` Pattern)
If a server is a Node.js project that you want to customize or isn't published to npm, you can store it in `modules/home/mcp/repos/` and have the wrapper build and run it from there.

**Critical:** The `repos/` directory and its contents must be tracked in git, or Nix flakes will silently ignore them.

```nix
# In your-wrapper.nix
{pkgs, ...}: let
  myServerWrapper = pkgs.writeShellApplication {
    name = "my-server-wrapper";
    runtimeInputs = [pkgs.nodejs];
    text = ''
      set -euo pipefail
      SRC_DIR="/home/joebutler/nix-config/modules/home/mcp/repos/my-server"
      cd "$SRC_DIR"
      ${pkgs.nodejs}/bin/npm ci
      ${pkgs.nodejs}/bin/npm run build
      exec ${pkgs.nodejs}/bin/node build/index.js "$@"
    '';
  };
in {
  home.packages = [myServerWrapper];
}
```

**Setup:**
1. Clone or copy the repo to `modules/home/mcp/repos/my-server/`
2. Run `git add modules/home/mcp/repos/` to track it
3. Ensure the repo has a `package-lock.json` for reproducible `npm ci`

#### Pattern B2: Runtime Git Clone (Alternative)
If you prefer not to store the source in your config repo, you can clone at runtime to `/tmp`. This is **impure and stateful**, but pragmatic.

```nix
# In your-wrapper.nix
runtimeInputs = [ pkgs.git pkgs.nodejs ];
text = ''
  CLONE_DIR="/tmp/my-server-src"
  if [ ! -d "$CLONE_DIR" ]; then
    git clone https://github.com/user/repo "$CLONE_DIR"
  fi
  cd "$CLONE_DIR"
  git fetch && git pull
  npm install
  exec node build/index.js "$@"
'';
```

#### Pattern C: Declarative Nix Build (The "Proper" Way)
If a project has a `package-lock.json` (for Node.js) or `Cargo.lock` (for Rust), using a declarative Nix builder like `pkgs.buildNpmPackage` or `pkgs.rustPlatform.buildRustPackage` is the most robust and "correct" approach. This was attempted for `anki-mcp-server` but failed due to the missing lock file. This approach requires getting correct hashes for all dependencies and is more involved. Refer to official Nixpkgs documentation for these functions if you choose this path.

### 4. Debugging a Failing Build
If `home-manager switch` or `hs` succeeds but the new command is not found, the build was likely silently ignored.
1.  First, check `git status` and `git add` your files.
2.  If it still fails, try a direct build command to get a more verbose error: `nix build .#homeConfigurations.joebutler.activation-script --show-trace`
